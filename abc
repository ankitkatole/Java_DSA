ANKIT KATOLE | PRACTICAL NO: 04
import java.util.Scanner;
public class DESDemo {
static int[] IP = {
58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,
62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,
57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3,
61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7
};
static int[] FP = {
40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,
38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,
36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,
34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25
};
static int[] E = {
32,1,2,3,4,5,4,5,6,7,8,9,8,9,10,11,12,13,
12,13,14,15,16,17,16,17,18,19,20,21,
20,21,22,23,24,25,24,25,26,27,28,29,
28,29,30,31,32,1
};
static int[] P = {
16,7,20,21,29,12,28,17,1,15,23,26,
5,18,31,10,2,8,24,14,32,27,3,9,
19,13,30,6,22,11,4,25
};
static String[] roundKeys = new String[16];
static {
String dummyKey = "011011001010110011010101010101010101010101010101";
for (int i = 0; i < 16; i++) roundKeys[i] = dummyKey;
}
static String textToBinary(String text) {
StringBuilder sb = new StringBuilder();
for (char c : text.toCharArray())
sb.append(String.format("%8s", Integer.toBinaryString(c)).replace(' ', '0'));
return sb.toString();
}
static String padTo64Bits(String bin) {
StringBuilder sb = new StringBuilder(bin);
while (sb.length() < 64) sb.append('0');
return sb.substring(0, 64);
}
static String permute(String block, int[] table) {
StringBuilder sb = new StringBuilder();
for (int i : table) sb.append(block.charAt(i - 1));
return sb.toString();
}
static String xor(String a, String b) {
StringBuilder sb = new StringBuilder();
for (int i = 0; i < a.length(); i++)
sb.append(a.charAt(i) == b.charAt(i) ? '0' : '1');

return sb.toString();
}
static String sboxSubstitution(String bits) {
int[][] S1 = {
{14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7},
{0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8},
{4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0},
{15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13}
};
StringBuilder result = new StringBuilder();
for (int i = 0; i < bits.length(); i += 6) {
String block = bits.substring(i, i + 6);
int row = Integer.parseInt("" + block.charAt(0) + block.charAt(5), 2);
int col = Integer.parseInt(block.substring(1, 5), 2);
int val = S1[row][col];
result.append(String.format("%4s", Integer.toBinaryString(val)).replace(' ', '0'));
}
return result.toString();
}
static String desEncrypt(String binaryPlaintext) {
String permuted = permute(binaryPlaintext, IP);
String L = permuted.substring(0, 32);
String R = permuted.substring(32);
System.out.println("Initial L: " + L);
System.out.println("Initial R: " + R + "\n");
for (int round = 0; round < 16; round++) {
String expandedR = permute(R, E);
String xored = xor(expandedR, roundKeys[round]);
String sboxOut = sboxSubstitution(xored);
String pboxOut = permute(sboxOut, P);
String newR = xor(L, pboxOut);
L = R;
R = newR;
System.out.println("Round " + (round + 1) + ":");
System.out.println(" L: " + L);
System.out.println(" R: " + R + "\n");
}
String finalBlock = R + L;
return permute(finalBlock, FP);
}
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
System.out.print("Enter plaintext (max 8 characters): ");
String input = sc.nextLine();
String binaryInput = textToBinary(input);
binaryInput = padTo64Bits(binaryInput);
System.out.println("\nBinary input (padded): " + binaryInput + "\n");
String ciphertextBinary = desEncrypt(binaryInput);
System.out.println("Final Ciphertext (binary): " + ciphertextBinary);
}
}
